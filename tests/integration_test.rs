/// Integration tests comparing our output against committed reference files.
///
/// Reference files are generated by `tests/generate_references.sh` (requires
/// bgzip, samtools, tabix) and committed to the repository.  Running `cargo
/// test` itself has no external tool dependencies.
///
/// Fixture files required in `tests/fixtures/`:
///   test.fasta, test.gff3
/// Reference files required in `tests/fixtures/reference/`:
///   test.fasta.bgz.fai, test.fasta.bgz.gzi, test.gff3.bgz.tbi
/// (Generate them with: tests/generate_references.sh)
use std::fs;
use std::io::Cursor;

use mgnify_wasm::htslib::{bgzf_compress, faidx_index_fasta, tabix_index_gff, BgzfReader};

const FASTA_FIXTURE: &str = "tests/fixtures/test.fasta";
const GFF_FIXTURE:   &str = "tests/fixtures/test.gff3";
const REF_FAI:       &str = "tests/fixtures/reference/test.fasta.bgz.fai";
const REF_GZI:       &str = "tests/fixtures/reference/test.fasta.bgz.gzi";
const REF_TBI:       &str = "tests/fixtures/reference/test.gff3.bgz.tbi";

fn read_fixture(path: &str) -> Vec<u8> {
    fs::read(path).unwrap_or_else(|e| panic!("cannot read {}: {}\n  (run tests/generate_references.sh to create reference files)", path, e))
}

fn compress_fasta() -> Vec<u8> {
    let raw = read_fixture(FASTA_FIXTURE);
    let mut bgzf = Vec::new();
    bgzf_compress(Cursor::new(raw), &mut bgzf).expect("bgzf_compress failed");
    bgzf
}

fn compress_gff() -> Vec<u8> {
    let raw = fs::read_to_string(GFF_FIXTURE)
        .unwrap_or_else(|e| panic!("cannot read {}: {}", GFF_FIXTURE, e));
    let preprocessed = mgnify_wasm::gff_preprocess(&raw);
    let mut bgzf = Vec::new();
    bgzf_compress(Cursor::new(preprocessed.as_bytes()), &mut bgzf).expect("bgzf_compress failed");
    bgzf
}

/// Compressing and then decompressing a FASTA returns the original bytes.
#[test]
fn bgzf_roundtrip_fasta() {
    let original = read_fixture(FASTA_FIXTURE);
    let bgzf = compress_fasta();

    let mut decompressed = Vec::new();
    let mut reader = BgzfReader::new(Cursor::new(&bgzf));
    std::io::Read::read_to_end(&mut reader, &mut decompressed).expect("BgzfReader failed");

    assert_eq!(decompressed, original, "decompressed FASTA differs from original");
}

/// Compressing and then decompressing a (preprocessed) GFF3 returns the preprocessed bytes.
#[test]
fn bgzf_roundtrip_gff() {
    let raw = fs::read_to_string(GFF_FIXTURE)
        .unwrap_or_else(|e| panic!("cannot read {}: {}", GFF_FIXTURE, e));
    let preprocessed = mgnify_wasm::gff_preprocess(&raw);
    let bgzf = compress_gff();

    let mut decompressed = Vec::new();
    let mut reader = BgzfReader::new(Cursor::new(&bgzf));
    std::io::Read::read_to_end(&mut reader, &mut decompressed).expect("BgzfReader failed");

    assert_eq!(decompressed, preprocessed.as_bytes(), "decompressed GFF differs from preprocessed original");
}

/// Our `.fai` index matches the reference produced by `samtools faidx`.
#[test]
fn fai_matches_samtools() {
    let bgzf = compress_fasta();
    let ref_fai = read_fixture(REF_FAI);

    let mut our_fai = Vec::new();
    let mut _gzi = Vec::new();
    faidx_index_fasta(Cursor::new(&bgzf), &mut our_fai, &mut _gzi)
        .expect("faidx_index_fasta failed");

    pretty_assertions::assert_eq!(
        String::from_utf8_lossy(&ref_fai),
        String::from_utf8_lossy(&our_fai),
        ".fai does not match samtools reference"
    );
}

/// Our `.gzi` index matches the reference produced by `samtools faidx`.
#[test]
fn gzi_matches_samtools() {
    let bgzf = compress_fasta();
    let ref_gzi = read_fixture(REF_GZI);

    let mut _fai = Vec::new();
    let mut our_gzi = Vec::new();
    faidx_index_fasta(Cursor::new(&bgzf), &mut _fai, &mut our_gzi)
        .expect("faidx_index_fasta failed");

    assert_eq!(ref_gzi, our_gzi, ".gzi does not match samtools reference");
}

/// Our `.tbi` index matches the reference produced by `tabix`.
/// Both files are BGZF-compressed; we decompress before comparing so that
/// differences in deflate implementation do not cause spurious failures.
#[test]
fn tbi_matches_tabix() {
    let bgzf = compress_gff();
    let ref_tbi_bgzf = read_fixture(REF_TBI);

    let mut our_tbi_bgzf = Vec::new();
    tabix_index_gff(Cursor::new(&bgzf), &mut our_tbi_bgzf).expect("tabix_index_gff failed");

    // Decompress both for comparison
    let mut ref_tbi = Vec::new();
    std::io::Read::read_to_end(
        &mut BgzfReader::new(Cursor::new(&ref_tbi_bgzf)),
        &mut ref_tbi,
    ).expect("decompressing reference TBI failed");

    let mut our_tbi = Vec::new();
    std::io::Read::read_to_end(
        &mut BgzfReader::new(Cursor::new(&our_tbi_bgzf)),
        &mut our_tbi,
    ).expect("decompressing our TBI failed");

    assert_eq!(ref_tbi, our_tbi, ".tbi does not match tabix reference");
}
